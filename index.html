<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent Visualization - Exploding Gradients</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            min-width: 200px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        input[type="range"] {
            width: 150px;
            margin: 10px 0;
        }
        
        .value-display {
            font-size: 1.2em;
            color: #ffeb3b;
            font-weight: bold;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .canvas-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            background: white;
            max-width: 100%;
            height: auto;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .info-card {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .info-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffeb3b;
            margin-bottom: 5px;
        }
        
        .info-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .explanation {
            background: rgba(255, 255, 255, 0.2);
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            line-height: 1.8;
        }
        
        .warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
            display: none;
        }
        
        .success {
            background: linear-gradient(45deg, #4caf50, #45a049);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
            display: none;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .github-link {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            text-decoration: none;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        .github-link:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .controls {
                gap: 15px;
            }
            
            .control-group {
                min-width: 150px;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <a href="#" class="github-link">‚≠ê Star on GitHub</a>
    
    <div class="container">
        <h1>üìà Gradient Descent Visualization</h1>
        <p style="text-align: center; font-size: 1.2em; margin-bottom: 30px;">
            Interactive demonstration of exploding gradients on a U-shaped function
        </p>
        
        <div class="controls">
            <div class="control-group">
                <label for="learningRate">Learning Rate</label>
                <input type="range" id="learningRate" min="0.01" max="2.0" step="0.01" value="0.1">
                <div class="value-display" id="lrValue">0.10</div>
            </div>
            
            <div class="control-group">
                <label for="startPosition">Starting Position</label>
                <input type="range" id="startPosition" min="-5" max="5" step="0.1" value="3">
                <div class="value-display" id="spValue">3.0</div>
            </div>
            
            <div class="control-group">
                <button onclick="startAnimation()">üöÄ Start Descent</button>
                <button onclick="resetAnimation()">üîÑ Reset</button>
            </div>
        </div>
        
        <div id="warning" class="warning">
            ‚ö†Ô∏è EXPLODING GRADIENTS! The optimization is diverging!
        </div>
        
        <div id="success" class="success">
            ‚úÖ CONVERGED! Found the minimum successfully!
        </div>
        
        <div class="info-panel">
            <div class="info-card">
                <div class="info-value" id="currentX">3.0</div>
                <div class="info-label">Current Position (x)</div>
            </div>
            <div class="info-card">
                <div class="info-value" id="currentLoss">9.0</div>
                <div class="info-label">Current Loss f(x)</div>
            </div>
            <div class="info-card">
                <div class="info-value" id="currentGradient">6.0</div>
                <div class="info-label">Current Gradient f'(x)</div>
            </div>
            <div class="info-card">
                <div class="info-value" id="stepCount">0</div>
                <div class="info-label">Steps Taken</div>
            </div>
        </div>
        
        <div class="canvas-container">
            <h3 style="color: #333; margin-top: 0;">Function: f(x) = x¬≤</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span style="color: #333;">Function Curve</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF5722;"></div>
                    <span style="color: #333;">Current Position</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span style="color: #333;">Gradient Vector</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0;"></div>
                    <span style="color: #333;">Path Taken</span>
                </div>
            </div>
            <canvas id="functionCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="explanation">
            <h3>üß† Understanding Exploding Gradients</h3>
            <p><strong>The U-Shaped Function:</strong> We're minimizing f(x) = x¬≤, which has its minimum at x = 0 where f(0) = 0.</p>
            <p><strong>The Gradient:</strong> The derivative f'(x) = 2x tells us which direction to move. Positive gradient means move left, negative means move right.</p>
            <p><strong>Normal Behavior (Small Learning Rate &lt; 0.5):</strong> The red dot smoothly slides down the curve toward the minimum at x = 0.</p>
            <p><strong>Exploding Gradients (Large Learning Rate &gt; 1.0):</strong> The red dot overshoots the minimum and bounces back and forth with increasing amplitude, never converging!</p>
            <p><strong>Key Insight:</strong> When learning_rate √ó |gradient| &gt; |distance_to_minimum|, the algorithm will overshoot and diverge.</p>
            
            <h3>üî¨ Experiments to Try:</h3>
            <ul>
                <li><strong>Learning Rate 0.05:</strong> Slow but steady convergence</li>
                <li><strong>Learning Rate 0.5:</strong> Fast optimal convergence</li>
                <li><strong>Learning Rate 1.0:</strong> Perfect oscillation (boundary case)</li>
                <li><strong>Learning Rate 1.5:</strong> Clear exploding gradients!</li>
            </ul>
            
            <h3>üìö Why This Matters:</h3>
            <p>This simple 1D example demonstrates the core mechanism behind exploding gradients in neural networks. In deep networks, gradients are computed through the chain rule across many layers, which can amplify this effect dramatically. The same overshooting behavior that causes divergence here can make neural network training completely unstable.</p>
        </div>
        
        <footer style="text-align: center; margin-top: 40px; opacity: 0.8;">
            <p>Created as an educational tool to visualize exploding gradients in gradient descent optimization</p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('functionCanvas');
        const ctx = canvas.getContext('2d');
        
        let animationId;
        let currentX = 3.0;
        let stepCount = 0;
        let path = [];
        let isAnimating = false;
        
        // Update control displays
        document.getElementById('learningRate').addEventListener('input', function(e) {
            document.getElementById('lrValue').textContent = parseFloat(e.target.value).toFixed(2);
        });
        
        document.getElementById('startPosition').addEventListener('input', function(e) {
            document.getElementById('spValue').textContent = parseFloat(e.target.value).toFixed(1);
            if (!isAnimating) {
                currentX = parseFloat(e.target.value);
                updateDisplay();
                drawFunction();
            }
        });
        
        // Function definitions
        function f(x) {
            return x * x; // f(x) = x¬≤
        }
        
        function fprime(x) {
            return 2 * x; // f'(x) = 2x
        }
        
        function drawFunction() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set up coordinate system
            const centerX = canvas.width / 2;
            const centerY = canvas.height - 50;
            const scaleX = 60; // pixels per unit
            const scaleY = 20; // pixels per unit
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(canvas.width - 50, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, canvas.height - 50);
            ctx.stroke();
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 0.5;
            for (let i = -6; i <= 6; i++) {
                if (i !== 0) {
                    const x = centerX + i * scaleX;
                    ctx.beginPath();
                    ctx.moveTo(x, 50);
                    ctx.lineTo(x, canvas.height - 50);
                    ctx.stroke();
                }
            }
            
            // Draw function curve f(x) = x¬≤
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let x = -6; x <= 6; x += 0.1) {
                const canvasX = centerX + x * scaleX;
                const canvasY = centerY - f(x) * scaleY;
                
                if (x === -6) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
            
            // Draw path taken
            if (path.length > 1) {
                ctx.strokeStyle = '#9C27B0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < path.length; i++) {
                    const canvasX = centerX + path[i] * scaleX;
                    const canvasY = centerY - f(path[i]) * scaleY;
                    
                    if (i === 0) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                }
                ctx.stroke();
                
                // Draw path points
                ctx.fillStyle = '#9C27B0';
                for (let i = 0; i < path.length - 1; i++) {
                    const canvasX = centerX + path[i] * scaleX;
                    const canvasY = centerY - f(path[i]) * scaleY;
                    ctx.beginPath();
                    ctx.arc(canvasX, canvasY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw current position
            const canvasX = centerX + currentX * scaleX;
            const canvasY = centerY - f(currentX) * scaleY;
            
            ctx.fillStyle = '#FF5722';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw gradient vector
            const gradient = fprime(currentX);
            const gradientLength = Math.min(Math.abs(gradient) * 10, 100); // Scale for visibility
            const gradientEndX = canvasX - Math.sign(gradient) * gradientLength;
            
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(canvasX, canvasY);
            ctx.lineTo(gradientEndX, canvasY);
            ctx.stroke();
            
            // Arrow head for gradient
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.moveTo(gradientEndX, canvasY);
            ctx.lineTo(gradientEndX + Math.sign(gradient) * 10, canvasY - 5);
            ctx.lineTo(gradientEndX + Math.sign(gradient) * 10, canvasY + 5);
            ctx.closePath();
            ctx.fill();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            // X-axis labels
            for (let i = -5; i <= 5; i++) {
                if (i !== 0) {
                    const x = centerX + i * scaleX;
                    ctx.fillText(i.toString(), x, centerY + 20);
                }
            }
            
            // Origin
            ctx.fillText('0', centerX - 15, centerY + 20);
            
            // Y-axis label
            ctx.textAlign = 'left';
            ctx.fillText('f(x) = x¬≤', centerX + 10, 70);
            
            // Current values
            ctx.fillStyle = '#FF5722';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`(${currentX.toFixed(2)}, ${f(currentX).toFixed(2)})`, canvasX + 10, canvasY - 10);
        }
        
        function updateDisplay() {
            document.getElementById('currentX').textContent = currentX.toFixed(3);
            document.getElementById('currentLoss').textContent = f(currentX).toFixed(3);
            document.getElementById('currentGradient').textContent = fprime(currentX).toFixed(3);
            document.getElementById('stepCount').textContent = stepCount;
        }
        
        function startAnimation() {
            if (isAnimating) return;
            
            isAnimating = true;
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const startPos = parseFloat(document.getElementById('startPosition').value);
            
            currentX = startPos;
            stepCount = 0;
            path = [currentX];
            
            document.getElementById('warning').style.display = 'none';
            document.getElementById('success').style.display = 'none';
            
            animateStep(learningRate);
        }
        
        function animateStep(learningRate) {
            const gradient = fprime(currentX);
            const newX = currentX - learningRate * gradient;
            
            currentX = newX;
            stepCount++;
            path.push(currentX);
            
            updateDisplay();
            drawFunction();
            
            // Check for convergence or divergence
            if (Math.abs(currentX) < 0.01) {
                // Converged!
                document.getElementById('success').style.display = 'block';
                isAnimating = false;
                return;
            }
            
            if (Math.abs(currentX) > 10 || stepCount > 50) {
                // Diverged!
                document.getElementById('warning').style.display = 'block';
                isAnimating = false;
                return;
            }
            
            // Continue animation
            animationId = setTimeout(() => animateStep(learningRate), 500);
        }
        
        function resetAnimation() {
            if (animationId) {
                clearTimeout(animationId);
            }
            isAnimating = false;
            
            currentX = parseFloat(document.getElementById('startPosition').value);
            stepCount = 0;
            path = [];
            
            document.getElementById('warning').style.display = 'none';
            document.getElementById('success').style.display = 'none';
            
            updateDisplay();
            drawFunction();
        }
        
        // Initial draw
        updateDisplay();
        drawFunction();
        
        // Handle window resize
        window.addEventListener('resize', function() {
            drawFunction();
        });
    </script>
</body>
</html>